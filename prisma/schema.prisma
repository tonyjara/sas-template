generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "cockroachdb"
    url      = env("DATABASE_URL")
}

model Account {
    id         String    @id @default(cuid())
    active     Boolean   @default(true)
    createdAt  DateTime  @default(now())
    updatedAt  DateTime? @updatedAt
    email      String    @unique
    password   String
    role       Role      @default(user)
    isVerified Boolean   @default(false)

    user User?

    PasswordRecoveryLinks PasswordRecoveryLinks[]
}

model User {
    id        String    @id @default(cuid())
    createdAt DateTime  @default(now())
    updatedAt DateTime? @updatedAt
    firstName String
    lastName  String
    image     String

    subscription Subscription?
    preferences  Preferences?

    paymentIntents PaymentIntent[]

    accountId      String          @unique
    account        Account         @relation(fields: [accountId], references: [id])
    supportTickets SupportTicket[]
}

model AccountVerificationLinks {
    id               String    @id @default(cuid())
    createdAt        DateTime  @default(now())
    updatedAt        DateTime? @updatedAt
    verificationLink String
    email            String
    hasBeenUsed      Boolean   @default(false)
}

model PasswordRecoveryLinks {
    id           String   @id @default(cuid())
    createdAt    DateTime @default(now())
    recoveryLink String
    email        String
    hasBeenUsed  Boolean  @default(false)
    account      Account? @relation(fields: [accountId], references: [id])
    accountId    String?
}

model Preferences {
    id                String   @id @default(cuid())
    createdAt         DateTime @default(now())
    updatedAt         DateTime @updatedAt
    hasSeenOnboarding Boolean  @default(false)

    showTranscriptionWarning Boolean @default(true)

    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId String @unique
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

//One row per user, if the user signed up after the 28th then move to the first of each month
model Subscription {
    id          String   @id @default(cuid())
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    active      Boolean
    isFreeTrial Boolean  @default(false)

    stripeCustomerId     String?
    stripeSubscriptionId String?
    creditActions        SubscriptionCreditsActions[]
    subscriptionItems    SubscriptionItem[]

    eventCancellationId String?
    cancellAt           DateTime?
    cancelledAt         DateTime?

    audio   AudioFile[]
    coupons Coupons[]

    user      User     @relation(fields: [userId], references: [id])
    userId    String   @unique
    product   Product? @relation(fields: [productId], references: [id])
    productId String?
}

model Coupons {
    id             String    @id @default(cuid())
    createdAt      DateTime  @default(now())
    updatedAt      DateTime  @updatedAt
    couponCode     String    @unique @default(cuid())
    hasBeenClaimed Boolean   @default(false)
    claimedAt      DateTime?
    expirationDate DateTime?

    chatInputCredits     Int @default(0)
    chatOutputCredits    Int @default(0)
    transcriptionMinutes Int @default(0)

    subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
    subscriptionId String?
}

// This is based on stripe products
model Product {
    id          String   @id @default(cuid())
    active      Boolean  @default(true)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    features    String
    payAsYouGo  String
    sortOrder   String
    description String
    name        String
    planType    PlanType @default(FREE)

    subscriptions Subscription[]

    prices Price[]
}

model Price {
    id                  String         @id @default(cuid())
    active              Boolean
    createdAt           DateTime       @default(now())
    updatedAt           DateTime       @updatedAt
    nickName            String
    sortOrder           String
    currency            String
    unit_amount_decimal String
    interval            String
    tag                 StripePriceTag

    subscriptionItems SubscriptionItem[]

    productId String
    product   Product @relation(fields: [productId], references: [id])
}

model SubscriptionItem {
    id        String         @id @default(cuid())
    createdAt DateTime       @default(now())
    updatedAt DateTime       @updatedAt
    active    Boolean
    priceTag  StripePriceTag

    subscription         Subscription? @relation(fields: [subscriptionId], references: [id])
    subscriptionId       String?
    stripeSubscriptionId String?
    price                Price?        @relation(fields: [priceId], references: [id])
    priceId              String?
}

model PaymentIntent {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    stripeProductId     String
    unit_amount_decimal String

    validatedByWebhook     Boolean   @default(false)
    validatedBySuccessPage Boolean   @default(false)
    confirmedByWebhookAt   DateTime?
    confirmationEventId    String?

    user   User?   @relation(fields: [userId], references: [id])
    userId String?
}

// Are billed monthly
model SubscriptionCreditsActions {
    //auto incrementing id
    id        Int      @id @default(sequence())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    currentAmount Decimal        @default(0) @db.Decimal(19, 4)
    prevAmount    Decimal        @default(0) @db.Decimal(19, 4)
    amount        Decimal        @default(0) @db.Decimal(19, 4)
    tag           StripePriceTag

    subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
    subscriptionId String?
}

model FeatureFlags {
    id                   String  @id @default(cuid())
    signupEnabled        Boolean @default(true)
    rssEnabled           Boolean @default(true)
    transcriptionEnabled Boolean @default(true)
    chatEnabled          Boolean @default(true)
    maintenance          Boolean @default(false)
}

model SupportTicket {
    id        Int                   @id @default(sequence())
    createdAt DateTime              @default(now())
    updatedAt DateTime              @updatedAt
    email     String
    subject   String
    message   String
    status    SupportTicketStatus
    priority  SupportTicketPriority
    type      SupportTicketType
    imageUrl  String?
    imageName String?

    userId String
    user   User   @relation(fields: [userId], references: [id])
}

model Logs {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    message   String
    level     String
    eventId   String
}

enum SupportTicketPriority {
    low
    medium
    high
    unsorted
}

enum SupportTicketStatus {
    open
    closed
    inProgress
}

enum SupportTicketType {
    question
    bug
    featureRequest
    unsorted
}

enum Role {
    admin
    user
    mod
    support
}

enum StripePriceTag {
    PLAN_FEE
    TRANSCRIPTION_MINUTE
    CHAT_INPUT
    CHAT_OUTPUT
    STORAGE_PER_GB
}

enum StripeInterval {
    month
    year
}

enum PlanType {
    TRIAL
    FREE
    HOBBY
    BASIC
    PRO
}

// Everything before this comment is must have for the template
model AudioFile {
    id           String   @id @default(cuid())
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt
    name         String
    blobName     String
    url          String
    isHostedByPS Boolean  @default(true)
    isSelected   Boolean  @default(false)
    length       Int //file size in bytes
    duration     Int //in seconds
    type         String   @default("audio/mpeg") //mp3

    subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
    subscriptionId String?
    peaks          Float[]

    @@unique([blobName, subscriptionId])
}
